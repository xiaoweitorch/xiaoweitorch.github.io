<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="笔记记录">
<meta property="og:type" content="website">
<meta property="og:title" content="Something">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Something">
<meta property="og:description" content="笔记记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Leading Werido">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Something</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?67bd87d41cd1946187174362f966b76e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Something</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0012ColorfulBlocks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0012ColorfulBlocks/" class="post-title-link" itemprop="url">0012 ColorfulBlocks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 11:03:00" itemprop="dateCreated datePublished" datetime="2020-05-14T11:03:00+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0012ColorfulBlocks/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/14/每天一道算法题/0012ColorfulBlocks/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>Colorful Blocks</font>

<blockquote>
<p>编号：0012</p>
<p>试题来源：<a href="https://atcoder.jp/contests/abc167/tasks/abc167_e" target="_blank" rel="noopener">AtCoder</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有$N$个连续排列成一行的方块，对他们进行涂色。总共有$M$种可以使用的颜色，不要求一定使用所有的颜色，最多有$K$对相邻的方块有相同的颜色(<strong>例如：涂色为11233，这里面有2对相邻的方块有相同的颜色</strong>)</p>
<blockquote>
<p>输入： N   M    K</p>
<p>输出：可能的次数mod(998244353)</p>
</blockquote>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>进行遍历判断，题目要求最多有$K$对相邻的方块有相同的颜色，定义$f(N,M,k)$为<strong>有$k$对相邻的方块有相邻的颜色对应的方案数目</strong>，这样题目要求的方案数目就是</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{K}f(N,M,k)</script><p>那么接下来就只要思考一下$f(N,M,k)$的求解方式。</p>
<p>首先思考，当$k=0$的时候，第一个方块可以放$M$种颜色，第二个方块为了和第一个不同，可以放$M-1$种颜色，同样的第三个为了和第二个方块不同，也可以放$M-1$种颜色，以此类推，后面的每一个方块都可以放$M-1$种颜色，因此$f(N,M,0)=M*(M-1)^{N-1}$</p>
<p>那么继续递推，当$k=1$的时候，首先题目中有$N-1$对相邻的方块，从中选出一个进行相邻，因此首先方案数乘$C_{n-1}^1$，然后假设选中的是第二个和第三个方块，那么第二个方块和第三个方块可以看成一个方块，因为他们的颜色必须相同，因此经过转换总共就只剩$N-1$个方块，同时还是有0对相邻方块，因此$f(N,M,1)=C_{n-1}^1*f(N-1,M,0)$</p>
<p>同样的这样递推下去，$f(N,M,i)=C_{n-1}^i*f(N-i,M,0)$</p>
<p>其中组合数$C_{n-1}^i$用递推的方式进行存储，$C_{n-1}^i=C_{n-1}^{i-1}*(n-i)/i$</p>
<p>但是因为这是取模运算，所以要用到<strong>费马小定理</strong>，</p>
<p>也就是当$mod$为质数的时候，$(1/i)\%mod=i^{mod-2}\%mod$</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line">ll n, m, k, c[<span class="number">200005</span>]; <span class="comment">//n,m,k如题意，c存储组合数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fp</span><span class="params">(ll x, ll y)</span>   <span class="comment">//实现的是pow(x,y)，然后进行取模运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) c[i] = c[i - <span class="number">1</span>] * (n - i) % mod * fp(i, mod - <span class="number">2</span>) % mod;  <span class="comment">//对组合数进行递推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        ans = (ans + m * fp(m - <span class="number">1</span>, n - i - <span class="number">1</span>) % mod * c[n - i - <span class="number">1</span>] % mod) % mod;  <span class="comment">//对答案进行递推</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>时间复杂度：整个过程中进行了两个遍历，同时还有在pow过程中的遍历，因此事件复杂度$O(nlogn)$</p>
<p>空间复杂度：$O(n)$用到的排列组合空间相当于是$n$值，虽然解答里面赋给了定值，但是实际上应该要大于等于n</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0011SkillUp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0011SkillUp/" class="post-title-link" itemprop="url">0011 SkillUp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-11 21:30:00" itemprop="dateCreated datePublished" datetime="2020-05-11T21:30:00+08:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0011SkillUp/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/11/每天一道算法题/0011SkillUp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>Skill Up</font>

<blockquote>
<p>编号：0011</p>
<p>试题来源：<a href="https://atcoder.jp/contests/abc167/tasks/abc167_c" target="_blank" rel="noopener">AtCoder</a></p>
</blockquote>
<h1 id="试题描述"><a href="#试题描述" class="headerlink" title="试题描述"></a>试题描述</h1><p>怪人想要学习$M$门算法，假设对于技艺的掌握程度是可以量化的，怪人的期望是对于这$M$门算法，每一门的掌握程度都要大于$X$。提高掌握程度的方法是读书，假设书店中共有$N$本书，其中第$i$本书的价格是$C_i$，对于第$j$门算法的提升程度是$A_{i,j}$。以上均为已知，判断能否满足怪人的期望，如果可以的话，请问最少花费？</p>
<blockquote>
<p>取值范围：</p>
<ul>
<li>所有值都是整数</li>
<li>$1\leq N, M\leq 12$</li>
<li>$1\leq X \leq 10^5$</li>
<li>$1\leq C_i \leq 10^5$</li>
<li>$0\leq A_{i,j}\leq 10^5$</li>
</ul>
</blockquote>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><blockquote>
<p>N    M   X</p>
<p>$C_1$    $A_{1,1}$    $A_{1,2}$    $\dotso$    $A_{1,M}$</p>
<p>$\vdots$</p>
<p>$C_N$    $A_{N,1}$    $A_{N,2}$    $\cdots$    $A_{N,M}$</p>
</blockquote>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>从头开始遍历，对于每本书都有买和不买两种可能，将$2^N$中可能全部遍历一遍，取其中的满足条件的最小价格，如果没有能够满足条件的，就输出-1</p>
<p>遍历过程利用的是<code>func</code>函数，两个参数<code>nn</code>和<code>sum</code>分别表示当前已经遍历到第几本书，和当前遍历过的价格和，对于第<code>i</code>本书，只有买和不买两种可能，因此<code>func(nn,sum)</code>继续递归调用只会有两种情况，买<code>func(nn+1,sum+c[nn])</code>，不买<code>func(nn+1,sum)</code>，注意在买的时候，同时要改变我们要提升的技能的点数。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM 2000000000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n, m, x, c[<span class="number">12</span>], a[<span class="number">12</span>][<span class="number">12</span>], wk[<span class="number">12</span>], mn;<span class="comment">//n、m、x、c、a都是题目意思,wk表示m门技能的掌握程度，mn表示最后的付款</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mn = MM;    <span class="comment">//初始给mn赋一个极大值，如果最后还是这个极大值，说明没有满足条件的解，输出-1就好</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)	wk[i] = <span class="number">0</span>;  <span class="comment">//把掌握程度置0</span></span><br><span class="line">	func(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//开始调用</span></span><br><span class="line">	<span class="keyword">if</span> (mn != MM)	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mn);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> nn, <span class="keyword">int</span> sum)</span>  <span class="comment">//把每一种情况都遍历了一遍</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, flg;</span><br><span class="line">	<span class="keyword">if</span> (nn == n) &#123;  <span class="comment">//递归到尽头</span></span><br><span class="line">		flg = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;  <span class="comment">//判断是否满足掌握程度大于X</span></span><br><span class="line">			<span class="keyword">if</span> (wk[i] &lt; x) &#123;</span><br><span class="line">				flg = <span class="number">0</span>;	<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flg == <span class="number">1</span>)	mn = min(mn, sum);  <span class="comment">//满足的话，更新mn</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		func(nn + <span class="number">1</span>, sum);    <span class="comment">//不买第nn本书</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			wk[i] += a[nn][i];</span><br><span class="line">		&#125;</span><br><span class="line">		func(nn + <span class="number">1</span>, sum + c[nn]);  <span class="comment">//买第nn本书</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			wk[i] -= a[nn][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<ul>
<li>时间复杂度：整个过程中对所有的$2^n$中情况均遍历了一遍，因此时间复杂度$O(2^n)$</li>
<li>空间复杂度：主要是递归调用的栈空间，栈空间深度为$n$，因此空间复杂度$O(n)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0010%20Pow(x,n)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0010%20Pow(x,n)/" class="post-title-link" itemprop="url">0010Pow(x,n)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-11 20:58:00" itemprop="dateCreated datePublished" datetime="2020-05-11T20:58:00+08:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0010%20Pow(x,n)/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/11/每天一道算法题/0010 Pow(x,n)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>Pow(x,n)</font>

<blockquote>
<p>编号：0010</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现$pow(x,n)$，即计算$x$的$n$次幂</p>
<blockquote>
<p>其中$-100.0 &lt; x&lt;100.0$</p>
<p>$n$是32位有符号整数，其数值范围是$[-2^{31},2^{31}-1]$，也就是<code>c++</code>中<code>int</code>的取值范围</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul>
<li><p>示例1：</p>
<p><img src="0010-01.jpg" alt="0010-01"></p>
</li>
<li><p>示例2：</p>
<p><img src="0010-02.jpg" alt="0010-02"></p>
</li>
<li><p>示例3：</p>
<p><img src="0010-03.jpg" alt="0010-03"></p>
</li>
</ul>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="递归-我的解法"><a href="#递归-我的解法" class="headerlink" title="递归(我的解法)"></a>递归(我的解法)</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于底数$x$来说，有特殊情况$x==1$，此时不用判断$n$直接输出$0$就好。</p>
<p>对于指数$n$来说，当$n==0$的时候，不适用于递归表达式，直接输出$1$就好</p>
<p>对于一般情况来说，$x^n$有两种可能，一种是$n$是奇数，另一种是$n$是偶数，当$n$是偶数的时候，显然$x^{n} = x^{\frac{n}{2}}<em>x^{\frac{n}{2}}$这里面，显然把$x^{\frac{n}{2}}$利用了两次，这样的话，就相对于逐个递乘减少了一般的工作量；当$n$时偶数的时候，$$x^{n} = x^{\frac{n}{2}}</em>x^{\frac{n}{2}} * x$$只是在之前的基础上多乘了一个x，计算步骤也是很小的。</p>
<p>然后递归的终止条件就是$n==1$，此时，只要返回$x$就好。</p>
<p>当计算$n&lt;0$的时候，我用的是$x^{n} = \frac{1}{x^{-n}}$，但是这里存在越界的可能，对于$-2^{31}$来说，其相反数$2^{31}$不能用<code>int</code>类型表示，因此我把式子改写成了$x^n=\frac{1}{x^{-n-1}*x}$这样就避免了$-n$越界的可能性。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>)   <span class="comment">//当底数为1的时候，直接输出1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)    <span class="comment">//当指数小于0的时候，先转换成指数大于0的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / (x * myPow(x, -(n + <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)   <span class="comment">//当指数为0的时候，直接输出1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)  <span class="comment">//当指数为1的时候，递归终止</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> result = myPow(x, n / <span class="number">2</span>);  <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)  <span class="comment">//偶数和结束分开讨论</span></span><br><span class="line">            <span class="keyword">return</span> result * result;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> result * result * x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//这个是因为程序要求一定要有返回值，所以加上的，无意义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：每一次递归仅进行了一次操作，一共进行了$logn$次递归，因此时间复杂度$O(logn)$</li>
<li>空间复杂度：整个过程中用到的空间是递归用到的栈空间，深度应当是$logn$，因此空间复杂度$O(logn)$</li>
</ul>
</blockquote>
<p>这是我自己第一次两个100%击败，有点意思—__—</p>
<h2 id="递归-官方解答"><a href="#递归-官方解答" class="headerlink" title="递归(官方解答)"></a>递归(官方解答)</h2><p>算法思路和复杂度分析和我的一样，不列举了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;  <span class="comment">//指数变成N，避免了溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;  <span class="comment">//指数为0的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);    <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;  <span class="comment">//这个对奇偶的利用有点简洁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N); <span class="comment">//对正负的利用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>三目运算符真好使</p>
<h2 id="迭代-官方解答"><a href="#迭代-官方解答" class="headerlink" title="迭代(官方解答)"></a>迭代(官方解答)</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>迭代思路用到了整数的二进制表示，$n$是一个十进制整数，它一定可以被转化成一个二进制数$i_ki_{k-1}\dotso i_0$，那么$n=2^{i_0}+2^{i_1}+\dotso + 2^{i_k}$，因此$x^n=x^{2^{i_0}}<em>\dotso </em>x^{2^{i_k}}$，因此只要知道了二进制数，可以求解其对应的$x^n$</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：整个过程中进行了$logn$层循环，因此时间复杂度为$O(logn)$</li>
<li>空间复杂度：显然$O(1)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0009%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0009%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="post-title-link" itemprop="url">0009二叉树的最近公共祖先</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 20:21:00" itemprop="dateCreated datePublished" datetime="2020-05-10T20:21:00+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0009%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/10/每天一道算法题/0009 二叉树的最近公共祖先/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>二叉树的最近公共祖先</font>

<blockquote>
<p>编号：0009</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="试题描述"><a href="#试题描述" class="headerlink" title="试题描述"></a>试题描述</h1><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p>
<p>公共祖先的定义为：对于有根树$T$的两个结点$p,q$，最近公共节点表示为一个结点$x$，满足$x$时$p,q$的祖先，且$x$的深度尽可能大(<strong>一个节点也可以是它自己的祖先</strong>)</p>
<blockquote>
<p>此题中所有的节点的值<code>val</code>都是唯一的</p>
<p>p,q为不同节点，且均存在于给定的二叉树中</p>
</blockquote>
<p>二叉树结构定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="0009-01.jpg" alt="0009-01"></p>
<p><img src="0009-02.jpg" alt="0009-02"></p>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/" target="_blank" rel="noopener">官方解答传送门</a></p>
<h2 id="递归-自己想的"><a href="#递归-自己想的" class="headerlink" title="递归(自己想的)"></a>递归(自己想的)</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>从根节点进行遍历，当遍历到$p,q$的时候，返回一个<code>vector&lt;TreeNode*&gt;</code>数组，存储他们的所有祖先，这样比较$p,q$的公共祖先，从深度最深的开始比较，最深的祖先就是所求。</p>
<p>时间主要浪费在我对数组进行了两次遍历</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; pList, qList;</span><br><span class="line">        get_child(root, p, pList);</span><br><span class="line">        get_child(root, q, qList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pIter = pList.begin(); pIter &lt; pList.end(); pIter++)  <span class="comment">//找到共同的祖先节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator it = find(qList.begin(), qList.end(), *pIter);</span><br><span class="line">            <span class="keyword">if</span> (it != qList.end())</span><br><span class="line">                <span class="keyword">return</span> (*pIter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get_child</span><span class="params">(TreeNode* root, TreeNode* destination, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; childlist)</span>  <span class="comment">//递归得到祖先的函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)  <span class="comment">//根节点为空，说明找到底了，也没找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == destination-&gt;val)  <span class="comment">//因为val可以代表节点，因此val相同，说明找到了目标节点，将其存入childList中（目标节点就是最深的祖先节点）</span></span><br><span class="line">        &#123;</span><br><span class="line">            childlist.push_back(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (get_child(root-&gt;left, destination, childlist) || get_child(root-&gt;right,destination,childlist))  <span class="comment">//如果返回为ture说明root是祖先节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            childlist.push_back(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：整个过程中对数进行了两次遍历，同时又对祖先数组进行了遍历，因此最坏情况事件复杂度为$O(n)+O(n)+O(logn)$，也就是$O(n)$</li>
<li>空间复杂度：整个过程中，用到了递归栈空间，最坏情况下也为$O(n)$</li>
</ul>
</blockquote>
<h2 id="递归思路-官方题解"><a href="#递归思路-官方题解" class="headerlink" title="递归思路(官方题解)"></a>递归思路(官方题解)</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$f_x$为$x$节点的子树是否包含$p$节点或者$q$节点，如果包含为<code>true</code>，如果不包含为<code>false</code>。</p>
<p>那么符合条件的最深的公共节点<code>x</code>一定满足如下条件$(f_{lson}\&amp;\&amp;f_{rson})||((x=p||x=q) \&amp;\&amp;(f_{lson}f_{rson}))$</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans; <span class="comment">//全局变量，存放公共祖先节点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//空节点返回false，递归终止</span></span><br><span class="line">        <span class="keyword">bool</span> lson = dfs(root-&gt;left, p, q);  <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">bool</span> rson = dfs(root-&gt;right, p, q); <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;  <span class="comment">//满足条件更新ans</span></span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><blockquote>
<ul>
<li>时间复杂度：$O(n)$，只进行了一次遍历</li>
<li>空间复杂度：递归所利用的栈空间，最坏情况下$O(n)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0008%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0008%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/" class="post-title-link" itemprop="url">0008最大正方形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-08 16:46:00" itemprop="dateCreated datePublished" datetime="2020-05-08T16:46:00+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0008%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/08/每天一道算法题/0008 最大正方形/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>最大正方形</font>

<blockquote>
<p>编号：0008</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="试题描述"><a href="#试题描述" class="headerlink" title="试题描述"></a>试题描述</h1><p>在一个由$0$和$1$组成的二维矩阵中，找到只包含1的最大正方形，并返回其<strong>面积</strong>。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="0008-01.jpg" alt="0008-01"></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/" target="_blank" rel="noopener">官方题解传送门</a></p>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>对<code>matrix</code>二维数组进行遍历，当遍历到<code>matrix[i][j] == 1</code>的时候，以<code>[i,j]</code>作为可能正方形的左上角进行检验，每次检验一行和一列，例如，已经判断出正方形边长为<code>tempLen</code>，下一次就检验第<code>i+tempLen</code>行和<code>j+tempLen</code>列，如果全为$1$，那么此次检验仍成功，继续。判断失败后，更新<code>maxLen</code>全局变量。</p>
<p>最后返回最大边长的平方，因为我们求解的是面积。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, tempLen = <span class="number">0</span>;  <span class="comment">//maxLen存储遇到的最大正方形边长，tempLen作为临时量，存储当前遇到的正方形边边长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size();i++)   <span class="comment">//两重循环遍历矩阵</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; matrix[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)   <span class="comment">//等于1的话进行判断</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tempLen = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(tempLen + i &lt; matrix.size() &amp;&amp; tempLen + j &lt; matrix[i].size())    <span class="comment">//注意一定要在矩阵范围内寻找</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">false</span>;   <span class="comment">//标定正常退出还是因为不满足退出</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; tempLen;m++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(matrix[i+m][j+tempLen] != <span class="string">'1'</span> || matrix[i+tempLen][j+m] != <span class="string">'1'</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                                </span><br><span class="line">                            <span class="keyword">if</span>(matrix[i + tempLen][j+tempLen] != <span class="string">'1'</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!flag)   <span class="comment">//正常退出tempLen+1，进行下一轮的判断</span></span><br><span class="line">                            tempLen++;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxLen = max(maxLen,tempLen);  <span class="comment">//更新maxLen</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen * maxLen;        <span class="comment">//返回面积</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>下面是官方题解</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;  <span class="comment">//判断一下矩形的形状</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;<span class="comment">//最大边长</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();<span class="comment">//取行数和列数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;    <span class="comment">//二重循环遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = max(maxSide, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = min(rows - i, columns - j);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123;</span><br><span class="line">                        <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">'0'</span> || matrix[i + m][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                            maxSide = max(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基本没啥差别，和我写的</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><blockquote>
<ul>
<li>时间复杂度：$O(m<em>n</em>min(m,n)^2)$；遍历整个矩阵的时间复杂度为$O(m*n)$，对于正方形，遍历的事件复杂度为$O(min(m,n)^2)$</li>
<li>空间复杂度：$O(1)$，整个过程中使用的空间复杂度是常数</li>
</ul>
</blockquote>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>$dp(i,j)$表示以$(i,j)$为右下角，且只包含$1$的正方形的边长最大值。</p>
<p>如果<code>matrix[i][j]==0</code>，那么显然不可能在一个只含有$1$的正方形中，因此$dp(i,j)=0$</p>
<p>如果<code>matrix[i][j]==1</code>，那么显然<code>dp[i][j]=min(dp(i-1,j),dp(i-1,j-1),dp(i,j-1))+1</code>。</p>
<p>得出状态转移方程</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;  <span class="comment">//判断矩形的形状</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;    <span class="comment">//正方形的最大边长</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();   <span class="comment">//判断一下行，列</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(columns))</span></span>;     <span class="comment">//创建一个dp矩形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;     <span class="comment">//二重循环遍历，动态规划</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = min(min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：$O(mn)$，整个过程中只进行两层遍历</li>
<li>空间复杂度：$O(mn)$，创建了一个和原始矩阵大小相同的矩阵$dp$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0007%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0007%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/" class="post-title-link" itemprop="url">0007另一个数的子树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-07 23:30:00" itemprop="dateCreated datePublished" datetime="2020-05-07T23:30:00+08:00">2020-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0007%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/07/每天一道算法题/0007 另一个树的子树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>另一个树的子树</font>

<blockquote>
<p>编号：0007</p>
<p>题目来源：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空二叉树$s$和$t$，检验$s$中是否包含和$t$具有相同结构和节点值的子树。$s$的一个子树包括$s$的一个节点和这个节点的所有子孙。$s$也可以看作它自身的一棵子树。</p>
<p>树的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul>
<li><p><img src="0007-01.jpg" alt="示例1"></p>
</li>
<li><p><img src="0007-02.jpg" alt="示例2"></p>
</li>
</ul>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方解答传送门</a></p>
<h2 id="递归检查"><a href="#递归检查" class="headerlink" title="递归检查"></a>递归检查</h2><blockquote>
<p>自己写的思路如下</p>
</blockquote>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>因为要求判断$s$中是否含有$t$这样的子树，那也就是说，如果含有就会有$s$的一个子树和$t$完全一样。所以可以递归的进行判断：如果$s$和$t$相同，那么显然返回<code>true</code>，如果不同，再分别那$s$的左子树和右子树和$t$进行比较，如果其中有相同的也返回$true$，一直递归到最后$s$变成$NULL$，递归终止。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;  <span class="comment">//判断是否为子树的递归调用</span></span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">NULL</span>)              <span class="comment">//空子树，递归终止</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (ifTheSame(s, t))        <span class="comment">//如果检查s和t一样，返回true</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> (isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t));<span class="comment">//检查左右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ifTheSame</span><span class="params">(TreeNode* s, TreeNode* t)</span>  <span class="comment">//判断两个树是否完全相同，也是递归判断</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>)          </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((s == <span class="literal">NULL</span> &amp;&amp; t != <span class="literal">NULL</span>) || (s != <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;val == t-&gt;val)</span><br><span class="line">			<span class="keyword">return</span> (ifTheSame(s-&gt;left, t-&gt;left) &amp;&amp; ifTheSame(s-&gt;right, t-&gt;right));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>官方题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((o &amp;&amp; !t) || (!o &amp;&amp; t) || (o-&gt;val != t-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(o-&gt;left, t-&gt;left) &amp;&amp; check(o-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(o, t) || dfs(o-&gt;left, t) || dfs(o-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：整个过程中总的时间是遍历s树的时间和每次比较的时间相乘，即$O(s\times t)$</p>
<p>空间复杂度：整个过程中用了两个递归函数，isSubtree更多依赖于s树的深度，ifTheSame更多依赖于t树的深度，最后的空间复杂度就是两者的较大值</p>
</blockquote>
<h2 id="DFS-序列上进行串匹配"><a href="#DFS-序列上进行串匹配" class="headerlink" title="$DFS$序列上进行串匹配"></a>$DFS$序列上进行串匹配</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>先序遍历(DFS)生成的序列中，子树是连续的，因此可以通过判断t生成的DFS序列是否是s的DFS的序列的子串。</p>
<p>但是这样做是不完全正确的，因为还存在即使是子串，但是左右位置发生变化，例如1是根，2是左孩子和1是根，2是右孩子的DFS序列相同，但是不是一个树，因此需要添加两个空值<code>lNull</code>和<code>rNull</code>，生成DFS序列之后，就可以进行子序列的匹配了。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sOrder, tOrder;  <span class="comment">//用来存放两个DFS序列</span></span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode *o)</span> </span>&#123;  <span class="comment">//得到树o的最大节点值，放入全局变量maxElement中，递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (!o) <span class="keyword">return</span>;</span><br><span class="line">        maxElement = max(maxElement, o-&gt;val);</span><br><span class="line">        getMaxElement(o-&gt;left);</span><br><span class="line">        getMaxElement(o-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode *o, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;tar)</span> </span>&#123; <span class="comment">//得到树o的DFS序列，放入tar中，递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (!o) <span class="keyword">return</span>;</span><br><span class="line">        tar.push_back(o-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) getDfsOrder(o-&gt;left, tar);</span><br><span class="line">        <span class="keyword">else</span> tar.push_back(lNull);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) getDfsOrder(o-&gt;right, tar);</span><br><span class="line">        <span class="keyword">else</span> tar.push_back(rNull);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fail(tOrder.size(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; tOrder[i] != tOrder[j + <span class="number">1</span>]) j = fail[j];</span><br><span class="line">            <span class="keyword">if</span> (tOrder[i] == tOrder[j + <span class="number">1</span>]) ++j;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sOrder[i] != tOrder[j + <span class="number">1</span>]) j = fail[j];</span><br><span class="line">            <span class="keyword">if</span> (sOrder[i] == tOrder[j + <span class="number">1</span>]) ++j;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        maxElement = INT_MIN;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用到了$KMP$算法，有丢丢不好理解，丢一个我觉得讲的很好的连接：<a href="https://blog.csdn.net/dark_cy/article/details/88698736" target="_blank" rel="noopener">CSDN</a>，理解了他画红的，基本上就理解了KMP算法。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：由于使用了KMP算法，因此最终事件复杂度$O(s+t)$，递归遍历两棵树的时间之和</li>
<li>空间复杂度：保存了两个DFS序列，辅助空间代价$O(s+t)$，两个栈空间，是$O(max\{d_s,d_t\})$，两棵树的深度的较大值，因此求和还为$O(s+t)$</li>
</ul>
</blockquote>
<p><strong>今日最大收获，KMP算法</strong></p>
<p>官方的hash算法我不太懂，就不贴了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0006%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0006%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="post-title-link" itemprop="url">0006验证二叉搜索树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-05 13:19:00" itemprop="dateCreated datePublished" datetime="2020-05-05T13:19:00+08:00">2020-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0006%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/05/每天一道算法题/0006 验证二叉搜索树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>验证二叉搜索树</font>

<blockquote>
<p>编号：0006</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>二叉搜索树的特征如下:</p>
<ul>
<li>节点的左子树只包含小于当前节点的数</li>
<li>节点的右子树只包含大于当前节点的数</li>
<li>所有的左子树和右子树自身必须也是二叉搜索树</li>
</ul>
<p>该题目中二叉树的结构定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode *left;</span><br><span class="line">      TreeNode *right;</span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul>
<li><blockquote>
<p>  <img src="0006-01.jpg" alt="0006-01"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="0006-02.jpg" alt="0006-02"></p>
</blockquote>
</li>
</ul>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方解答</a></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>因为要满足右子树的所有值大于节点，左子树的所有值小于节点，那么因此每一个节点上的数都应该有其理论最大值和最小值<code>max</code>和<code>min</code>，节点上的数要在<code>(min,max)</code>之间，然后当更新对该节点的左节点进行判断，那么<code>max</code>要改变为<code>root-&gt;val</code>，同样的，更新对右节点进行判断，<code>min</code>改变为<code>root-&gt;val</code>。</p>
<p>在最开始的根节点，<code>min</code>和<code>max</code>的初值我设定的是<code>long long</code>格式的<code>LLONG_MAX</code>和<code>LLONG_MIN</code>，因为树上的节点可能存在有确实值为<code>INT_MAX</code>和<code>INT_MIN</code>的情况，这样可能无法判断。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)     <span class="comment">//若根节点就为空，直接认为是二叉搜索树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;left,root-&gt;val,LLONG_MIN))  <span class="comment">//&amp;&amp;运算符先判断前部分，若root-&gt;left为空，不进行后面的判断，否则进入递归循环，对其左子树进行判断，最大值为root-&gt;val，最小值为LLONG_MIN</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;right,LLONG_MAX,root-&gt;val))<span class="comment">//同对左子树的判断，区别只是最小值改变为root-&gt;val</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//如果两重检验均成功，那么返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> max, <span class="keyword">long</span> <span class="keyword">long</span> min)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(root-&gt;val &gt; min &amp;&amp; root-&gt;val &lt; max))   <span class="comment">//判断节点值是否在(min,max)之间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;left,root-&gt;val,min))<span class="comment">//判断左子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;right,max,root-&gt;val))<span class="comment">//判断右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比我的简洁在原函数中没有对根节点进行额外的判断，而是也像正常的节点一样扔进递归中。</p>
<p>同时递归中的根节点判断是否为空也是扔进递归中，而不是进入递归之前。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：递归调用过程中，所有的节点都要被访问一次，进行条件判断，因此时间复杂度为$O(n)$</p>
<p>空间复杂度：为栈空间所占内存，也即递归的深度，当二叉树仅有一条链的时候，递归深度为n，因此时间复杂度为$O(n)$</p>
</blockquote>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>二叉搜索树中序遍历得到的值构成的序列一定是升序的。因此可以通过检验升序遍历过程中，当前节点是否大于前一节点的值即可。</p>
<p><strong>中序遍历</strong>就是先遍历左子树，再遍历根节点，最后遍历右子树</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;    <span class="comment">//利用栈实现中序遍历</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> inorder = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;  <span class="comment">//初始定义前一个节点的值为int值得最小减1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() || root != <span class="literal">nullptr</span>) &#123; <span class="comment">//中序遍历</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;   <span class="comment">//遍历完其左子树</span></span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = <span class="built_in">stack</span>.top();        <span class="comment">//弹出左节点</span></span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root -&gt; val &lt;= inorder) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度分析：要访问二叉搜索树的每一个节点，因此时间复杂度为$O(n)$</p>
<p>空间复杂度分析：栈存储的空间，在极端情况下，二叉搜索树仅有一条链，那么就会导致栈存储n，因此空间复杂度$O(n)$</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0005%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0005%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1/" class="post-title-link" itemprop="url">0005跳跃游戏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-04 15:31:00" itemprop="dateCreated datePublished" datetime="2020-05-04T15:31:00+08:00">2020-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0005%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/04/每天一道算法题/0005 跳跃游戏Ⅱ/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size= 8>跳跃游戏Ⅱ</font>

<blockquote>
<p>编号：0005</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个<strong>非负整数数组</strong>，最初位于数组的第一个位置，数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。目标是使用最少的跳跃次数到达数组的最后一个位置。输出最少的跳跃次数。</p>
<blockquote>
<p>假设你总是可以到达数组的最后一个位置</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><blockquote>
<p>输入：[2,3,1,1,4]</p>
<p>输出：2</p>
<p>解释：从下标为0跳到下标为1，再从下标为1跳至最后一个位置，共两步</p>
</blockquote>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/" target="_blank" rel="noopener">官方解答传送门</a></p>
<h2 id="反向查找出发位置"><a href="#反向查找出发位置" class="headerlink" title="反向查找出发位置"></a>反向查找出发位置</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>想要到达最后一个位置，那么可以找到所有可以一步跳至最后一个位置的位置，需要满足<code>nums[i]+i &gt;= nums.size()-1</code>，所有满足这样条件的位置，我们选择<code>i</code>最小的，这样方便其他的位置到达<code>i</code>,这时候<code>i</code>就作为新的<code>target</code>，进行进一步的判断，一直到最后的<code>target == 0</code>，循环终止。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我自己写的代码(c++)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>, target = nums.size() - <span class="number">1</span>, tempTarget = target;   <span class="comment">//times是跳跃步数，target是当前要达到的目标位置下标，tempTarget是一个临时的target，最后进行比较决定取不取</span></span><br><span class="line">        <span class="keyword">while</span> (target != <span class="number">0</span>)    <span class="comment">//当target为0的时候，循环终止，逆向搜索达到终点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            times++;          <span class="comment">//每一次进入循环，都是新的一次跳跃，步数+1</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; target / <span class="number">2</span> + <span class="number">1</span>; i++)   <span class="comment">//从0开始遍历到满足条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= target)        <span class="comment">//若从头开始满足条件，那么直接赋给新的target，然后退出循环</span></span><br><span class="line">                &#123;</span><br><span class="line">                    target = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (target - i - <span class="number">1</span> + nums[target - i - <span class="number">1</span>] &gt;= target)<span class="comment">//这个相当于从后向前遍历，类似于双指针向中间进发</span></span><br><span class="line">                    tempTarget = target - i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target = min(target, tempTarget);    <span class="comment">//新的target取较小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该思路用<code>c++</code>写会超出时间限制，未通过测试。(不是太明白)</p>
<p>官方解答用<code>java</code>写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> position = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                    position = i;</span><br><span class="line">                    steps++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：整个过程中，有两层嵌套遍历，在最坏的情况下，也就是[1,1,1,1,1,1…]这样的情况下，遍历的总次数为$\sum_{i=1}^n(n-i)$，因此$O(n^2)$</p>
<p>空间复杂度，只申请了常数个变量，没有用栈，因此$O(1)$</p>
</blockquote>
<h2 id="正向查找可到达的最大位置"><a href="#正向查找可到达的最大位置" class="headerlink" title="正向查找可到达的最大位置"></a>正向查找可到达的最大位置</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>从左向右遍历数组，找到其能够到达的最大边界，例如最开始查找a[0]，将边界值<code>end</code>更新为<code>a[0]</code>所能到达的最远点，也就是<code>a[0]+0</code>，然后在遍历<code>a[1..a[0]+0]</code>的过程中，不断更新其下一步能够到达的最远点<code>maxPos</code>，，然后当到达边界<code>end</code>的时候，说明要进行下一步跳跃，<code>step++</code>，同时更新<code>end</code>为<code>maxPos</code></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = <span class="number">0</span>, n = nums.size(), end = <span class="number">0</span>, step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxPos &gt;= i) &#123;</span><br><span class="line">                maxPos = max(maxPos, i + nums[i]);</span><br><span class="line">                <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                    end = maxPos;</span><br><span class="line">                    ++step;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：整个过程中，只遍历了一次数组，因此时间复杂度$O(n)$</p>
<p>空间复杂度：申请了常数个变量$O(1)$</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0004%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0004%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" class="post-title-link" itemprop="url">0004无重复字符的最长子串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-03 19:45:00" itemprop="dateCreated datePublished" datetime="2020-05-03T19:45:00+08:00">2020-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0004%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/03/每天一道算法题/0004 无重复字符的最长子串/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>无重复字符的最长子串</font>

<blockquote>
<p>编号：0004</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/submissions/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串，找出其中不含有重复字符的<strong>最长子串</strong>的长度。(注意，子串指的是原字符串中连续的部分)</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ol>
<li><blockquote>
<p>输入：<code>&quot;abcabcbb&quot;</code></p>
<p>输出：3</p>
<p>解释：无重复字符的最长子串<code>&quot;abc&quot;</code>，长度为3</p>
</blockquote>
</li>
<li><blockquote>
<p>输入：<code>&quot;bbbbb&quot;</code></p>
<p>输出：1</p>
<p>解释：无重复字符的最长子串<code>&quot;b&quot;</code>，长度为1</p>
</blockquote>
</li>
<li><blockquote>
<p>输入：<code>&quot;pwwkew&quot;</code></p>
<p>输出：3</p>
<p>解释：无重复字符的最长子串<code>&quot;wke&quot;</code>，长度为3</p>
</blockquote>
</li>
</ol>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>对字符串进行遍历，遍历过程中设置一个<code>string</code>变量<code>tempString</code>用来存储含当前字符的最长子串。如果遍历的当前字符<code>s[i]</code>并没有在<code>tempString</code>里，那么调用<code>push_back()</code>函数，将其添入<code>tempString</code>末尾；如果已存在<code>tempString</code>里，那么首先获取当前<code>tempString</code>的长度<code>size</code>和最大长度<code>max</code>做对比，取较大值更新<code>max</code>，然后找到<code>s[i]</code>在<code>tempString</code>中的位置<code>k</code>，删除<code>tempString[0..k]</code>，然后再调用<code>push_back()</code>函数将其添入<code>tempString</code>末尾。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tempString;           <span class="comment">//存储当前不含重复字符的串</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, temp = <span class="number">0</span>;   <span class="comment">//max代表已遍历过的最长串的长度，temp存储s[i]在tempString中的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = tempString.find(s[i]);  <span class="comment">//利用find函数找到s[i]在tempString中的位置</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">-1</span>)      <span class="comment">//s[i]未在tempString中出现</span></span><br><span class="line">                tempString.push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">//s[i]在tempString中出现过</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (max &lt; tempString.size())    <span class="comment">//更新max的值</span></span><br><span class="line">                    max = tempString.size();</span><br><span class="line">                tempString.erase(<span class="number">0</span>, temp + <span class="number">1</span>);  <span class="comment">//删除tempString[0..temp]，保证tempString中不含s[i]</span></span><br><span class="line">                tempString.push_back(s[i]);    <span class="comment">//将s[i]加入tempString末尾</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; tempString.size())     <span class="comment">//遍历结束再更新一次</span></span><br><span class="line">            max = tempString.size();</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p>执行用时：12ms，击败81.01%</p>
<p>内存消耗：6.9MB，击败100%</p>
</blockquote>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：在整个过程中，只进行了一层遍历，对于遍历每个字符<code>s[i]</code>，进行操作最多不超过3，因此时间复杂度为$O(n)$</p>
<p>空间复杂度：整个过程中申请了<code>string</code>类型变量<code>tempString</code>，以及<code>int</code>类型变量<code>max,temp</code>，最坏的情况就是<code>tempString</code>存储了整个<code>s</code>，因此空间复杂度$O(n)$</p>
</blockquote>
<h2 id="滑动窗口-官方题解"><a href="#滑动窗口-官方题解" class="headerlink" title="滑动窗口(官方题解)"></a>滑动窗口(官方题解)</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/" target="_blank" rel="noopener">官方题解传送门</a></p>
<h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>使用两个指针表示字符串中某个不含重复字符的子串的左右边界。依次将左指针向右移动一个，然后开始不断向右移动右指针，直到遇到该字串中已存在的字符，那么继续移动左指针。设置一个<code>max</code>，存储过程中遇到的子串的最大长度。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>这里用到了我不了解的数据结构<code>hash集合</code>，因此直接照抄官方注释</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.erase(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.insert(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：$O(n)$，其中$n$ 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>
<p>空间复杂度：O(|$\Sigma$|)，其中 $\Sigma$ 表示字符集（即字符串中可以出现的字符），|$\Sigma$| 表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 |$\Sigma$| = 128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为O(∣Σ∣)。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0003%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0003%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/" class="post-title-link" itemprop="url">0003最大子序和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-03 19:31:00" itemprop="dateCreated datePublished" datetime="2020-05-03T19:31:00+08:00">2020-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0003%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/03/每天一道算法题/0003 最大子序和/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size= 8>最大子序和</font>

<blockquote>
<p>编号:0003</p>
<p>昨天出去玩，少写了一道，今天补上</p>
<p>题目来源：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组<code>nums</code>，找到一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><blockquote>
<p>输入：<code>[-2,-1,-3,4,-1,2,1,-5,4]</code></p>
<p>输出：<code>6</code></p>
<p>解释：连续子数组<code>[4,-1,2,1]</code>的和最大，为<code>6</code></p>
</blockquote>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><blockquote>
<p>自己没想出来，直接看的官方题解</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/" target="_blank" rel="noopener">官方题解传送门</a></p>
<p>官方题解方法有二，动态规划，分治法</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>动态规划是将整个数组归纳考虑，假设我们已经知道了以第<code>i-1</code>个数结尾的<em>连续子数组的最大和</em>$f(i-1)$，显然以第<code>i</code>个数结尾的<em>连续子数组的最大和</em>的可能取值要么为$f(i-1)+nums[i]$，要么就<code>nums[i]</code>单独成一段，也就是<code>nums[i]</code>，在这两个数中我们取最大值，也就是说</p>
<script type="math/tex; mode=display">
f(i)=max\{f(i-1)+nums[i],nums[i]\}</script><p>有因为显然$f(0)=nums[0]$，因此我们可以利用这个递推公式，从第一个数开始计算。</p>
<p>因为我们在计算$f(i)$的时候，只关心$f(i-1)和nums[i]$，因此不用把整个$f(i)$数组保存下来，只需设置一个<code>pre</code>保存$f(i-1)$就好了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码如下(我按照官方题解的思路自己写的代码，很麻烦)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max, pre;</span><br><span class="line">        max = nums[<span class="number">0</span>];</span><br><span class="line">        pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre + nums[i] &gt; nums[i])</span><br><span class="line">                pre = pre+nums[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(pre &gt; max)</span><br><span class="line">                max = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码如下(官方代码)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;x: nums) &#123;</span><br><span class="line">            pre = max(pre + x, x);</span><br><span class="line">            maxAns = max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="提交结果"><a href="#提交结果" class="headerlink" title="提交结果"></a>提交结果</h3><blockquote>
<p>执行用时：8ms，击败74.51%</p>
<p>内存消耗：6.9MB   击败100%</p>
</blockquote>
<h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><blockquote>
<p>时间复杂度：整个过程中只是对数组进行一遍遍历，每次遍历的时候进行两次<code>max</code>比较操作，因此时间复杂度$O(n)$</p>
<p>空间复杂度：值设置了两个变量<code>pre</code>,<code>max</code>因此空间消耗为常数，空间复杂度为$O(1)$</p>
</blockquote>
<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>分治法是将问题进行拆分，此题我们处理的问题是从<code>[l,r]</code>区间中找出最大字段和，那么在拆分区间的时候，可以以其中间值<code>mid=(l+r)/2</code>作为分治求解的划分。</p>
<p>对于区间中，我们想要了解的内容有这些</p>
<ul>
<li><code>lSum</code>表示<code>[l,r]</code>中以<code>l</code>为左端点的最大子段和</li>
<li><code>rSum</code>表示<code>[l,r]</code>中以<code>r</code>为右端点的最大子段和</li>
<li><code>mSum</code>表示<code>[l,r]</code>内的最大子段和</li>
<li><code>iSum</code>表示<code>[l,r]</code>的区间和</li>
</ul>
<p>首先知道当划分到<code>l==r</code>的问题是可以简单求解的，此时<code>lSum = rSum = mSum = iSum = nums[l]</code></p>
<p>那么接下来要知道怎么求解合并后的区间的这四个量</p>
<p>首先<code>iSum</code>最好求解，只要把<code>[l,mid]</code>的<code>iSum</code>加上<code>[mid,r]</code>的<code>iSum</code>就很容易求得</p>
<p>然后当求解<code>rSum</code>的时候，它有两种可能，第一种就是<code>[mid,r]</code>的<code>rSum</code>，符合以<code>r</code>为右端点的要求，第二个就是<code>[l,mid]</code>的<code>rSum</code>加上<code>[mid,r]</code>的<code>iSum</code>，这两段显然是连续的，同时又符合以<code>r</code>为右端点。求其最大值赋给<code>rSum</code>，就好</p>
<p>求解<code>lSum</code>同上，也有两种可能，(1)<code>[l,mid]</code>的<code>lSum</code>，(2)<code>[l,mid]</code>的<code>iSum</code>加上<code>[mid,r]</code>的<code>lSum</code></p>
<p>求解<code>mSum</code>，若不跨越中间值<code>mid</code>，那么显然其取值就是左区间的<code>mSum</code>和右区间的<code>mSum</code>进行比较。如果跨越了，那就是左子区间的<code>lSum</code>加上右子区间的的<code>rSum</code>，三者取最大</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码如下(官方代码)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> lSum, rSum, mSum, iSum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">pushUp</span><span class="params">(Status l, Status r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iSum = l.iSum + r.iSum;</span><br><span class="line">        <span class="keyword">int</span> lSum = max(l.lSum, l.iSum + r.lSum);</span><br><span class="line">        <span class="keyword">int</span> rSum = max(r.rSum, r.iSum + l.rSum);</span><br><span class="line">        <span class="keyword">int</span> mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);</span><br><span class="line">        <span class="keyword">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (Status) &#123;a[l], a[l], a[l], a[l]&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Status lSub = get(a, l, m);</span><br><span class="line">        Status rSub = get(a, m + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> pushUp(lSub, rSub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>).mSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p>执行用时：4ms    击败97.65%</p>
<p>内存消耗：7.1MB  击败100%</p>
</blockquote>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：我们这里相当于对二叉树的所有结点进行遍历，最终遍历时间为$O(\sum_{i=1}^{logn}2^{i-1})=O(n)$，因此时间复杂度为$O(n)$</p>
<p>空间复杂度：遍历过程中，递归使用$O(logn)$的栈，时间复杂度$O(logn)$</p>
</blockquote>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f/" target="_blank" rel="noopener">传送门</a></p>
<h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>就是求解出其所有子序然后分别求和，找出其中的最大值就好</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> numsSize = <span class="keyword">int</span>(nums.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; numsSize; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; max)</span><br><span class="line">                    max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p>执行用时：600ms     击败5.06%</p>
<p>内存消耗：7.1MB      击败100%</p>
</blockquote>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度，整个过程中，每一次对<code>i</code>的遍历，都进行了$n-i$次比较，因此最终的操作次数为$\sum_{i=0}^n(n-i)$，为$O(n)$</p>
<p>空间复杂度：只定义了两个变量，<code>max</code>和<code>numsSize</code>，因此空间复杂度为$O(1)$</p>
</blockquote>
<h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><h3 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h3><p>这里利用的其实和动态规划有些类似，动态规划比较的是$f(i-1)+nums[i]$和$nums[i]$，可以明显的发现，也就是说只有当$f(i-1) &lt; 0$的时候，才采用后者，这里就用<code>sum</code>存储前面的<code>nums</code>之和，只有当<code>sum</code>小于零的时候，才把<code>sum</code>清零，从下一位置开始进行重新求和相加。</p>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> numsSize = <span class="keyword">int</span>(nums.size());</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            result = max(result, sum);</span><br><span class="line">            <span class="comment">//如果sum &lt; 0，重新开始找子序串</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="提交结果-1"><a href="#提交结果-1" class="headerlink" title="提交结果"></a>提交结果</h3><blockquote>
<p>执行用时：8ms，击败74.51%</p>
<p>内存消耗：6.9MB，击败100%</p>
</blockquote>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度，整个过程中对数组进行一次遍历，时间复杂度$O(n)$</p>
<p>空间复杂度：只设置了<code>result,numsSize,sum</code>常数个变量，空间复杂度$O(1)$</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leading Werido</p>
  <div class="site-description" itemprop="description">笔记记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leading Werido</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://leadingWerido.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
