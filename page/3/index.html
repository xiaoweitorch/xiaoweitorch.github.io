<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="笔记记录">
<meta property="og:type" content="website">
<meta property="og:title" content="Something">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Something">
<meta property="og:description" content="笔记记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Leading Werido">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Something</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?67bd87d41cd1946187174362f966b76e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Something</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/18/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0015%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/18/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0015%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/" class="post-title-link" itemprop="url">0015重新排列句子中的单词</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-18 22:44:00" itemprop="dateCreated datePublished" datetime="2020-05-18T22:44:00+08:00">2020-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/18/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0015%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/18/每天一道算法题/0015重新排列句子中的单词/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>重新排列句子中的单词</font>

<blockquote>
<p>编号：0015</p>
<p>题目来源：<a href="https://leetcode-cn.com/problems/rearrange-words-in-a-sentence/" target="_blank" rel="noopener">leetcode189周赛</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><em>句子</em>是一个用空格分隔单词的字符串。给你一个满足下述格式的句子<code>text</code>：</p>
<ul>
<li>句子的首字母大写</li>
<li><code>text</code>中的每个单词都用单个空格分隔</li>
</ul>
<p>请重新排列<code>text</code>中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。</p>
<p>请同样按上述格式返回新的句子。</p>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>首先题目给的是一个<code>string</code>类型的变量，我们要把其按照空格进行拆分。</p>
<p>按照空格拆分的方法有两种：</p>
<p>一种是暴力遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i] != <span class="string">' '</span>) <span class="comment">//非空格压入temp中</span></span><br><span class="line">                temp.push_back(text[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                word.push_back(temp);  <span class="comment">//把temp存入word中</span></span><br><span class="line">                sort.push_back(make_pair(temp.size(), word.size() - <span class="number">1</span>));</span><br><span class="line">                temp.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法是利用<code>stringstream</code>，我们知道<code>&gt;&gt;</code>运算符输入的时候，会把空白符作为分隔符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (ss &gt;&gt; temp) &#123;   <span class="comment">//这里的ss就是stringstream</span></span><br><span class="line">            words.push_back(temp);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>然后注意要把第一个单词的首字母由大写转为小写。</p>
<p>然后对其进行稳定排序，这里用到了标准库中的函数<code>stable_sort</code>，保证排序前后相同的量，顺序不变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.size() &lt; b.size();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>然后将其逐个添加在<code>result</code>函数的末尾即可，注意最后要将<code>result</code>的首字母大写。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://leetcode-cn.com/problems/rearrange-words-in-a-sentence/solution/rearrange-words-in-a-sentence-by-ikaruga/" target="_blank" rel="noopener">代码传送门</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">arrangeWords</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; temp) &#123;</span><br><span class="line">        words.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!words.empty()) &#123;</span><br><span class="line">        words[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">tolower</span>(words[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.size() &lt; b.size();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : words) &#123;</span><br><span class="line">        ans += s;</span><br><span class="line">        ans += <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ans.empty()) &#123;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="built_in">toupper</span>(ans[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.pop_back();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<ul>
<li>时间复杂度：整个过程中，进行了遍历时间复杂度为$O(n)$，稳定排序时间复杂度为$O(nlgn)$，因此总的时间复杂度为$O(nlogn)$</li>
<li>空间复杂度：过程中使用了<code>word</code>存储每一个单词，因此空间复杂度为$O(n)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/17/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0014%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/17/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0014%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/" class="post-title-link" itemprop="url">0014数位成本和为目标值的最大数字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-17 15:43:00" itemprop="dateCreated datePublished" datetime="2020-05-17T15:43:00+08:00">2020-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/17/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0014%E6%95%B0%E4%BD%8D%E6%88%90%E6%9C%AC%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/17/每天一道算法题/0014数位成本和为目标值的最大数字/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>数位成本和为目标值的最大数字</font>

<blockquote>
<p>编号：0014</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定整数数组<code>cost</code>和一个整数<code>target</code>。返回满足如下规则的可以得到的<strong>最大整数</strong>：</p>
<ul>
<li>给当前结果添加一个数位<code>i+1</code>的成本为<code>cost[i]</code>(<code>cost</code>数组的下标从0开始)</li>
<li>总成本必须<strong>恰好</strong>等于<code>target</code></li>
<li>添加的位数中没有数字0</li>
</ul>
<p>返回类型<code>string</code></p>
<p>如果无法得到任何整数，那么返回<code>0</code>。</p>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>很显然这是一个<em>0-1完全背包问题</em>。</p>
<p>我用的是暴力做法，时间复杂度太高，失败了</p>
<p><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/comments/400223" target="_blank" rel="noopener">参考代码</a></p>
<p><code>target</code>是目标的花费，显然，<code>cost</code>数组中的每一个值都是正数，因为一旦存在<code>0</code>，那么可以无穷添加，就没有最大值了。所以$cost[i]\geq 1$。因此可以设置一个temp数组，其中元素是<code>string</code>类型，<code>temp[i]</code>存储当总花费为<code>i</code>的时候产生的最大<code>string</code>。</p>
<p>显然有如下递推公式</p>
<p><code>temp[target] = max{temp[target - cost[i]]+cost[i],cost[i] + temp[target - cost[i]]}</code>，如果$target - cost[i] == 0$说明这是第一个添加的元素。如果$target - cost[i] &lt; 0$说明，该<code>target</code>没有满足条件的<code>string</code>；如果<code>temp[target - cost[i]]</code>对应的<code>string</code>为空，说明它不存在，那么自然不能在一个不存在的字符串上加数位因此也不存在。</p>
<p>通过递推公式，一个个遍历<code>temp[i]</code>，最后就能够解决问题</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = cost.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cost2num;  <span class="comment">//key存放的是花费，对应得是下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;   <span class="comment">//更新花费map</span></span><br><span class="line">            <span class="keyword">if</span>(cost2num.find(cost[i]) == cost2num.end() || cost2num[cost[i]] &lt; i + <span class="number">1</span>) &#123;</span><br><span class="line">                cost2num[cost[i]] = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">temp</span><span class="params">(target + <span class="number">1</span>, <span class="string">""</span>)</span></span>;  <span class="comment">//vector数组得长度为target+1,初始值均为空字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;  <span class="comment">//从1开始，逐渐提升target的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [cost, num]: cost2num) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = i - cost;       <span class="comment">//如果添加了当前数位，是在temp[i-cost]的基础上添加的</span></span><br><span class="line">                <span class="keyword">if</span>(index == <span class="number">0</span> || index &gt; <span class="number">0</span> &amp;&amp; temp[index] != <span class="string">""</span>) &#123; <span class="comment">//如果index == 0说明当前添加的i是第一个数位;如果index&gt;0，那么需要temp[i-cost]有合适的取值，才能添加新的数位</span></span><br><span class="line">                    <span class="built_in">string</span> second = to_string(num);</span><br><span class="line">                    <span class="built_in">string</span> new_str = temp[index] &gt; second? temp[index] + second: second + temp[index];  <span class="comment">//产生添加数位之后的string</span></span><br><span class="line">                    <span class="keyword">if</span>(new_str.size() &gt; temp[i].size() || new_str.size() == temp[i].size() &amp;&amp; new_str &gt; temp[i]) &#123;  <span class="comment">//和当前temp[i]进行对比，谁大选谁</span></span><br><span class="line">                        temp[i] = new_str;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp[target] == <span class="string">""</span>? <span class="string">"0"</span>: temp[target];  <span class="comment">//非空返回string，否则返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<ul>
<li>时间复杂度：整个过程中遍历了$O(target)$的时间，同时每一次都进行了比较操作以及对9个可以添加的数位的比较，最终的时间复杂度为$O(n)$</li>
<li>空间复杂度：申请了$O(target)$的额外空间，时间复杂度为$O(n)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0013BracketSequencing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0013BracketSequencing/" class="post-title-link" itemprop="url">0013BracketSequencing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 15:54:00" itemprop="dateCreated datePublished" datetime="2020-05-15T15:54:00+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/15/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0013BracketSequencing/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/15/每天一道算法题/0013BracketSequencing/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size= 8>Bracket Sequencing</font>

<blockquote>
<p>编号：0013</p>
<p>题目来源：<a href="https://atcoder.jp/contests/abc167/tasks/abc167_f" target="_blank" rel="noopener">AtCoder</a></p>
</blockquote>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出$N$个字符串，全都是由<code>(</code>和<code>)</code>组成的，判断$S_1,S_2,\cdots,S_N$能否以合理的顺序，满足其中的<code>(</code>和<code>)</code>配对成功。（注意配对的<code>(</code>和<code>)</code>一定是<code>(</code>在前，<code>)</code>在后）</p>
<blockquote>
<p>变量范围：</p>
<ul>
<li>$1\leq N \leq 10^6$</li>
<li>$S_i$的长度最多为$10^6$</li>
<li>$S_i$非空数组，且仅包含<code>(</code>和<code>)</code></li>
</ul>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><blockquote>
<p>N</p>
<p>$S_1$</p>
<p>$S_2$</p>
<p>$\vdots$</p>
<p>$S_N$</p>
</blockquote>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>如果可以排列成满足条件的序列，输出<code>Yes</code>，反之输出<code>No</code></p>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p>首先可以将字符转化为数字方便统计，可以设<code>(</code>为1，那么因为<code>)</code>和<code>(</code>相配对，所以设<code>)</code>为-1。那么对于任何一个字符串，有意义的量有两个，一个是<code>totalNum</code>，也就是这个串中遍历完之后的数字和，若为负数，说明其中<code>)</code>较多，反之说明<code>(</code>较多；另一个是<code>minNum</code>，说明到从开始到任意字符$S[i]$为止的最小和。比如说<code>(()(</code>的<code>totalNum=2</code>，<code>minNum=1</code>.</p>
<p>显然，要想满足题目中的配对要求，那么也就是说从头开始，到任意字符的数字和要为非负数，而且最终遍历完所有的字符串，要求数字和必须为0。</p>
<p>假设<code>TotalNum</code>是遍历到字符串$S_i$之前的数字和，那么要求<code>TotalNum+minNum &gt;= 0</code>，满足条件就更新<code>TotalNum</code>，新的<code>TotalNum=TotalNum+totalNum</code>。</p>
<p>那么如何排序字符串$S_i$，保证尽可能满足这个条件呢？</p>
<p>显然可以按照<code>minNum</code>从大到小进行排列（<code>totalNum&gt;0</code>），但是<code>totalNum &gt;0</code>和<code>totalNum&lt;0</code>显然是两种情况，应该分开来讨论，所以说设置两个数组<code>v1,v2</code>一个用来存储<code>totalNum&gt;0</code>，一个用来存储<code>totalNum &lt;0</code>，那么最终两个数组<code>v1和v2</code>的<code>TotalNum</code>应该互为相反数。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; P;   <span class="comment">//定义pair类型，first存放minNUm，second存放totalNum</span></span><br><span class="line"><span class="keyword">const</span> ll INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, n) for (ll i = 0; i &lt; (int)(n); i++)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; v1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; v2;</span><br><span class="line"></span><br><span class="line">    rep(i, n) &#123;  <span class="comment">//对每个字符串S更新first,second</span></span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        ll m2 = <span class="number">0</span>; ll m1 = INF;</span><br><span class="line">        ll now = <span class="number">0</span>;</span><br><span class="line">        rep(j, s.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">'('</span>) &#123;</span><br><span class="line">                now += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="string">')'</span>) &#123;</span><br><span class="line">                now -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m1 = min(m1, now);  <span class="comment">//更新minNum值</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now &gt; <span class="number">0</span>)v1.push_back(make_pair(m1, now));  <span class="comment">//根据totalNum的正负进行分组</span></span><br><span class="line">        <span class="keyword">else</span> v2.push_back(make_pair(m1 - now, -now));  <span class="comment">//这里为了方便，对小于0的进行了反转，让他们变成大于零的数字进行统计</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(v1.begin(), v1.end());   <span class="comment">//对两数组进行排序，默认是升序</span></span><br><span class="line">    sort(v2.begin(), v2.end());</span><br><span class="line">    reverse(v1.begin(), v1.end());   <span class="comment">//改为降序</span></span><br><span class="line">    reverse(v2.begin(), v2.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> ans = <span class="string">"Yes"</span>;</span><br><span class="line">    ll now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rep(i, v1.size()) &#123;   <span class="comment">//如果任意字符串会有TotalNum&lt;0，则失败</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now + v1[i].first &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="string">"No"</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        now += v1[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    ll now1 = <span class="number">0</span>;</span><br><span class="line">    rep(i, v2.size()) &#123;    <span class="comment">//同样如此</span></span><br><span class="line">        <span class="keyword">if</span> (now1 + v2[i].first &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans = <span class="string">"No"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now1 += v2[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now1 != now)ans = <span class="string">"No"</span>;   <span class="comment">//如果前后残余不一样，也失败</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<ul>
<li>时间复杂度：整个过程进行了两次排序，时间复杂度$O(nlogn)$，对数组进行遍历，时间复杂度$O(n)$，因此总的时间复杂度为$O(nlogn)$</li>
<li>空间复杂度：$O(n)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0012ColorfulBlocks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0012ColorfulBlocks/" class="post-title-link" itemprop="url">0012 ColorfulBlocks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-14 11:03:00" itemprop="dateCreated datePublished" datetime="2020-05-14T11:03:00+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0012ColorfulBlocks/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/14/每天一道算法题/0012ColorfulBlocks/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>Colorful Blocks</font>

<blockquote>
<p>编号：0012</p>
<p>试题来源：<a href="https://atcoder.jp/contests/abc167/tasks/abc167_e" target="_blank" rel="noopener">AtCoder</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有$N$个连续排列成一行的方块，对他们进行涂色。总共有$M$种可以使用的颜色，不要求一定使用所有的颜色，最多有$K$对相邻的方块有相同的颜色(<strong>例如：涂色为11233，这里面有2对相邻的方块有相同的颜色</strong>)</p>
<blockquote>
<p>输入： N   M    K</p>
<p>输出：可能的次数mod(998244353)</p>
</blockquote>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>进行遍历判断，题目要求最多有$K$对相邻的方块有相同的颜色，定义$f(N,M,k)$为<strong>有$k$对相邻的方块有相邻的颜色对应的方案数目</strong>，这样题目要求的方案数目就是</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{K}f(N,M,k)</script><p>那么接下来就只要思考一下$f(N,M,k)$的求解方式。</p>
<p>首先思考，当$k=0$的时候，第一个方块可以放$M$种颜色，第二个方块为了和第一个不同，可以放$M-1$种颜色，同样的第三个为了和第二个方块不同，也可以放$M-1$种颜色，以此类推，后面的每一个方块都可以放$M-1$种颜色，因此$f(N,M,0)=M*(M-1)^{N-1}$</p>
<p>那么继续递推，当$k=1$的时候，首先题目中有$N-1$对相邻的方块，从中选出一个进行相邻，因此首先方案数乘$C_{n-1}^1$，然后假设选中的是第二个和第三个方块，那么第二个方块和第三个方块可以看成一个方块，因为他们的颜色必须相同，因此经过转换总共就只剩$N-1$个方块，同时还是有0对相邻方块，因此$f(N,M,1)=C_{n-1}^1*f(N-1,M,0)$</p>
<p>同样的这样递推下去，$f(N,M,i)=C_{n-1}^i*f(N-i,M,0)$</p>
<p>其中组合数$C_{n-1}^i$用递推的方式进行存储，$C_{n-1}^i=C_{n-1}^{i-1}*(n-i)/i$</p>
<p>但是因为这是取模运算，所以要用到<strong>费马小定理</strong>，</p>
<p>也就是当$mod$为质数的时候，$(1/i)\%mod=i^{mod-2}\%mod$</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line">ll n, m, k, c[<span class="number">200005</span>]; <span class="comment">//n,m,k如题意，c存储组合数</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fp</span><span class="params">(ll x, ll y)</span>   <span class="comment">//实现的是pow(x,y)，然后进行取模运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ret = ret * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">1</span>; ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) c[i] = c[i - <span class="number">1</span>] * (n - i) % mod * fp(i, mod - <span class="number">2</span>) % mod;  <span class="comment">//对组合数进行递推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">        ans = (ans + m * fp(m - <span class="number">1</span>, n - i - <span class="number">1</span>) % mod * c[n - i - <span class="number">1</span>] % mod) % mod;  <span class="comment">//对答案进行递推</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<p>时间复杂度：整个过程中进行了两个遍历，同时还有在pow过程中的遍历，因此事件复杂度$O(nlogn)$</p>
<p>空间复杂度：$O(n)$用到的排列组合空间相当于是$n$值，虽然解答里面赋给了定值，但是实际上应该要大于等于n</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0011SkillUp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0011SkillUp/" class="post-title-link" itemprop="url">0011 SkillUp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-11 21:30:00" itemprop="dateCreated datePublished" datetime="2020-05-11T21:30:00+08:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0011SkillUp/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/11/每天一道算法题/0011SkillUp/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>Skill Up</font>

<blockquote>
<p>编号：0011</p>
<p>试题来源：<a href="https://atcoder.jp/contests/abc167/tasks/abc167_c" target="_blank" rel="noopener">AtCoder</a></p>
</blockquote>
<h1 id="试题描述"><a href="#试题描述" class="headerlink" title="试题描述"></a>试题描述</h1><p>怪人想要学习$M$门算法，假设对于技艺的掌握程度是可以量化的，怪人的期望是对于这$M$门算法，每一门的掌握程度都要大于$X$。提高掌握程度的方法是读书，假设书店中共有$N$本书，其中第$i$本书的价格是$C_i$，对于第$j$门算法的提升程度是$A_{i,j}$。以上均为已知，判断能否满足怪人的期望，如果可以的话，请问最少花费？</p>
<blockquote>
<p>取值范围：</p>
<ul>
<li>所有值都是整数</li>
<li>$1\leq N, M\leq 12$</li>
<li>$1\leq X \leq 10^5$</li>
<li>$1\leq C_i \leq 10^5$</li>
<li>$0\leq A_{i,j}\leq 10^5$</li>
</ul>
</blockquote>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><blockquote>
<p>N    M   X</p>
<p>$C_1$    $A_{1,1}$    $A_{1,2}$    $\dotso$    $A_{1,M}$</p>
<p>$\vdots$</p>
<p>$C_N$    $A_{N,1}$    $A_{N,2}$    $\cdots$    $A_{N,M}$</p>
</blockquote>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>从头开始遍历，对于每本书都有买和不买两种可能，将$2^N$中可能全部遍历一遍，取其中的满足条件的最小价格，如果没有能够满足条件的，就输出-1</p>
<p>遍历过程利用的是<code>func</code>函数，两个参数<code>nn</code>和<code>sum</code>分别表示当前已经遍历到第几本书，和当前遍历过的价格和，对于第<code>i</code>本书，只有买和不买两种可能，因此<code>func(nn,sum)</code>继续递归调用只会有两种情况，买<code>func(nn+1,sum+c[nn])</code>，不买<code>func(nn+1,sum)</code>，注意在买的时候，同时要改变我们要提升的技能的点数。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM 2000000000</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n, m, x, c[<span class="number">12</span>], a[<span class="number">12</span>][<span class="number">12</span>], wk[<span class="number">12</span>], mn;<span class="comment">//n、m、x、c、a都是题目意思,wk表示m门技能的掌握程度，mn表示最后的付款</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c[i]);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mn = MM;    <span class="comment">//初始给mn赋一个极大值，如果最后还是这个极大值，说明没有满足条件的解，输出-1就好</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)	wk[i] = <span class="number">0</span>;  <span class="comment">//把掌握程度置0</span></span><br><span class="line">	func(<span class="number">0</span>, <span class="number">0</span>);  <span class="comment">//开始调用</span></span><br><span class="line">	<span class="keyword">if</span> (mn != MM)	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mn);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> nn, <span class="keyword">int</span> sum)</span>  <span class="comment">//把每一种情况都遍历了一遍</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, flg;</span><br><span class="line">	<span class="keyword">if</span> (nn == n) &#123;  <span class="comment">//递归到尽头</span></span><br><span class="line">		flg = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;  <span class="comment">//判断是否满足掌握程度大于X</span></span><br><span class="line">			<span class="keyword">if</span> (wk[i] &lt; x) &#123;</span><br><span class="line">				flg = <span class="number">0</span>;	<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flg == <span class="number">1</span>)	mn = min(mn, sum);  <span class="comment">//满足的话，更新mn</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		func(nn + <span class="number">1</span>, sum);    <span class="comment">//不买第nn本书</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			wk[i] += a[nn][i];</span><br><span class="line">		&#125;</span><br><span class="line">		func(nn + <span class="number">1</span>, sum + c[nn]);  <span class="comment">//买第nn本书</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			wk[i] -= a[nn][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><blockquote>
<ul>
<li>时间复杂度：整个过程中对所有的$2^n$中情况均遍历了一遍，因此时间复杂度$O(2^n)$</li>
<li>空间复杂度：主要是递归调用的栈空间，栈空间深度为$n$，因此空间复杂度$O(n)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0010%20Pow(x,n)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0010%20Pow(x,n)/" class="post-title-link" itemprop="url">0010Pow(x,n)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-11 20:58:00" itemprop="dateCreated datePublished" datetime="2020-05-11T20:58:00+08:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0010%20Pow(x,n)/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/11/每天一道算法题/0010 Pow(x,n)/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size = 8>Pow(x,n)</font>

<blockquote>
<p>编号：0010</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现$pow(x,n)$，即计算$x$的$n$次幂</p>
<blockquote>
<p>其中$-100.0 &lt; x&lt;100.0$</p>
<p>$n$是32位有符号整数，其数值范围是$[-2^{31},2^{31}-1]$，也就是<code>c++</code>中<code>int</code>的取值范围</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul>
<li><p>示例1：</p>
<p><img src="0010-01.jpg" alt="0010-01"></p>
</li>
<li><p>示例2：</p>
<p><img src="0010-02.jpg" alt="0010-02"></p>
</li>
<li><p>示例3：</p>
<p><img src="0010-03.jpg" alt="0010-03"></p>
</li>
</ul>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><h2 id="递归-我的解法"><a href="#递归-我的解法" class="headerlink" title="递归(我的解法)"></a>递归(我的解法)</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>对于底数$x$来说，有特殊情况$x==1$，此时不用判断$n$直接输出$0$就好。</p>
<p>对于指数$n$来说，当$n==0$的时候，不适用于递归表达式，直接输出$1$就好</p>
<p>对于一般情况来说，$x^n$有两种可能，一种是$n$是奇数，另一种是$n$是偶数，当$n$是偶数的时候，显然$x^{n} = x^{\frac{n}{2}}<em>x^{\frac{n}{2}}$这里面，显然把$x^{\frac{n}{2}}$利用了两次，这样的话，就相对于逐个递乘减少了一般的工作量；当$n$时偶数的时候，$$x^{n} = x^{\frac{n}{2}}</em>x^{\frac{n}{2}} * x$$只是在之前的基础上多乘了一个x，计算步骤也是很小的。</p>
<p>然后递归的终止条件就是$n==1$，此时，只要返回$x$就好。</p>
<p>当计算$n&lt;0$的时候，我用的是$x^{n} = \frac{1}{x^{-n}}$，但是这里存在越界的可能，对于$-2^{31}$来说，其相反数$2^{31}$不能用<code>int</code>类型表示，因此我把式子改写成了$x^n=\frac{1}{x^{-n-1}*x}$这样就避免了$-n$越界的可能性。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>)   <span class="comment">//当底数为1的时候，直接输出1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)    <span class="comment">//当指数小于0的时候，先转换成指数大于0的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / (x * myPow(x, -(n + <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)   <span class="comment">//当指数为0的时候，直接输出1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)  <span class="comment">//当指数为1的时候，递归终止</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> result = myPow(x, n / <span class="number">2</span>);  <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)  <span class="comment">//偶数和结束分开讨论</span></span><br><span class="line">            <span class="keyword">return</span> result * result;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> result * result * x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//这个是因为程序要求一定要有返回值，所以加上的，无意义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：每一次递归仅进行了一次操作，一共进行了$logn$次递归，因此时间复杂度$O(logn)$</li>
<li>空间复杂度：整个过程中用到的空间是递归用到的栈空间，深度应当是$logn$，因此空间复杂度$O(logn)$</li>
</ul>
</blockquote>
<p>这是我自己第一次两个100%击败，有点意思—__—</p>
<h2 id="递归-官方解答"><a href="#递归-官方解答" class="headerlink" title="递归(官方解答)"></a>递归(官方解答)</h2><p>算法思路和复杂度分析和我的一样，不列举了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;  <span class="comment">//指数变成N，避免了溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;  <span class="comment">//指数为0的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);    <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;  <span class="comment">//这个对奇偶的利用有点简洁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N); <span class="comment">//对正负的利用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>三目运算符真好使</p>
<h2 id="迭代-官方解答"><a href="#迭代-官方解答" class="headerlink" title="迭代(官方解答)"></a>迭代(官方解答)</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>迭代思路用到了整数的二进制表示，$n$是一个十进制整数，它一定可以被转化成一个二进制数$i_ki_{k-1}\dotso i_0$，那么$n=2^{i_0}+2^{i_1}+\dotso + 2^{i_k}$，因此$x^n=x^{2^{i_0}}<em>\dotso </em>x^{2^{i_k}}$，因此只要知道了二进制数，可以求解其对应的$x^n$</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：整个过程中进行了$logn$层循环，因此时间复杂度为$O(logn)$</li>
<li>空间复杂度：显然$O(1)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0009%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0009%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="post-title-link" itemprop="url">0009二叉树的最近公共祖先</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 20:21:00" itemprop="dateCreated datePublished" datetime="2020-05-10T20:21:00+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0009%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/10/每天一道算法题/0009 二叉树的最近公共祖先/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>二叉树的最近公共祖先</font>

<blockquote>
<p>编号：0009</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="试题描述"><a href="#试题描述" class="headerlink" title="试题描述"></a>试题描述</h1><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p>
<p>公共祖先的定义为：对于有根树$T$的两个结点$p,q$，最近公共节点表示为一个结点$x$，满足$x$时$p,q$的祖先，且$x$的深度尽可能大(<strong>一个节点也可以是它自己的祖先</strong>)</p>
<blockquote>
<p>此题中所有的节点的值<code>val</code>都是唯一的</p>
<p>p,q为不同节点，且均存在于给定的二叉树中</p>
</blockquote>
<p>二叉树结构定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="0009-01.jpg" alt="0009-01"></p>
<p><img src="0009-02.jpg" alt="0009-02"></p>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/" target="_blank" rel="noopener">官方解答传送门</a></p>
<h2 id="递归-自己想的"><a href="#递归-自己想的" class="headerlink" title="递归(自己想的)"></a>递归(自己想的)</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>从根节点进行遍历，当遍历到$p,q$的时候，返回一个<code>vector&lt;TreeNode*&gt;</code>数组，存储他们的所有祖先，这样比较$p,q$的公共祖先，从深度最深的开始比较，最深的祖先就是所求。</p>
<p>时间主要浪费在我对数组进行了两次遍历</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt; pList, qList;</span><br><span class="line">        get_child(root, p, pList);</span><br><span class="line">        get_child(root, q, qList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> pIter = pList.begin(); pIter &lt; pList.end(); pIter++)  <span class="comment">//找到共同的祖先节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt;::iterator it = find(qList.begin(), qList.end(), *pIter);</span><br><span class="line">            <span class="keyword">if</span> (it != qList.end())</span><br><span class="line">                <span class="keyword">return</span> (*pIter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get_child</span><span class="params">(TreeNode* root, TreeNode* destination, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; childlist)</span>  <span class="comment">//递归得到祖先的函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)  <span class="comment">//根节点为空，说明找到底了，也没找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == destination-&gt;val)  <span class="comment">//因为val可以代表节点，因此val相同，说明找到了目标节点，将其存入childList中（目标节点就是最深的祖先节点）</span></span><br><span class="line">        &#123;</span><br><span class="line">            childlist.push_back(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (get_child(root-&gt;left, destination, childlist) || get_child(root-&gt;right,destination,childlist))  <span class="comment">//如果返回为ture说明root是祖先节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            childlist.push_back(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：整个过程中对数进行了两次遍历，同时又对祖先数组进行了遍历，因此最坏情况事件复杂度为$O(n)+O(n)+O(logn)$，也就是$O(n)$</li>
<li>空间复杂度：整个过程中，用到了递归栈空间，最坏情况下也为$O(n)$</li>
</ul>
</blockquote>
<h2 id="递归思路-官方题解"><a href="#递归思路-官方题解" class="headerlink" title="递归思路(官方题解)"></a>递归思路(官方题解)</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义$f_x$为$x$节点的子树是否包含$p$节点或者$q$节点，如果包含为<code>true</code>，如果不包含为<code>false</code>。</p>
<p>那么符合条件的最深的公共节点<code>x</code>一定满足如下条件$(f_{lson}\&amp;\&amp;f_{rson})||((x=p||x=q) \&amp;\&amp;(f_{lson}f_{rson}))$</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans; <span class="comment">//全局变量，存放公共祖先节点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//空节点返回false，递归终止</span></span><br><span class="line">        <span class="keyword">bool</span> lson = dfs(root-&gt;left, p, q);  <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">bool</span> rson = dfs(root-&gt;right, p, q); <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;  <span class="comment">//满足条件更新ans</span></span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><blockquote>
<ul>
<li>时间复杂度：$O(n)$，只进行了一次遍历</li>
<li>空间复杂度：递归所利用的栈空间，最坏情况下$O(n)$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0008%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0008%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/" class="post-title-link" itemprop="url">0008最大正方形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-08 16:46:00" itemprop="dateCreated datePublished" datetime="2020-05-08T16:46:00+08:00">2020-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0008%20%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/08/每天一道算法题/0008 最大正方形/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>最大正方形</font>

<blockquote>
<p>编号：0008</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="试题描述"><a href="#试题描述" class="headerlink" title="试题描述"></a>试题描述</h1><p>在一个由$0$和$1$组成的二维矩阵中，找到只包含1的最大正方形，并返回其<strong>面积</strong>。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><img src="0008-01.jpg" alt="0008-01"></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/" target="_blank" rel="noopener">官方题解传送门</a></p>
<h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>对<code>matrix</code>二维数组进行遍历，当遍历到<code>matrix[i][j] == 1</code>的时候，以<code>[i,j]</code>作为可能正方形的左上角进行检验，每次检验一行和一列，例如，已经判断出正方形边长为<code>tempLen</code>，下一次就检验第<code>i+tempLen</code>行和<code>j+tempLen</code>列，如果全为$1$，那么此次检验仍成功，继续。判断失败后，更新<code>maxLen</code>全局变量。</p>
<p>最后返回最大边长的平方，因为我们求解的是面积。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, tempLen = <span class="number">0</span>;  <span class="comment">//maxLen存储遇到的最大正方形边长，tempLen作为临时量，存储当前遇到的正方形边边长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;matrix.size();i++)   <span class="comment">//两重循环遍历矩阵</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; matrix[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)   <span class="comment">//等于1的话进行判断</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tempLen = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(tempLen + i &lt; matrix.size() &amp;&amp; tempLen + j &lt; matrix[i].size())    <span class="comment">//注意一定要在矩阵范围内寻找</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">false</span>;   <span class="comment">//标定正常退出还是因为不满足退出</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; tempLen;m++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(matrix[i+m][j+tempLen] != <span class="string">'1'</span> || matrix[i+tempLen][j+m] != <span class="string">'1'</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                                </span><br><span class="line">                            <span class="keyword">if</span>(matrix[i + tempLen][j+tempLen] != <span class="string">'1'</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!flag)   <span class="comment">//正常退出tempLen+1，进行下一轮的判断</span></span><br><span class="line">                            tempLen++;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxLen = max(maxLen,tempLen);  <span class="comment">//更新maxLen</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen * maxLen;        <span class="comment">//返回面积</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>下面是官方题解</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;  <span class="comment">//判断一下矩形的形状</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;<span class="comment">//最大边长</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();<span class="comment">//取行数和列数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;    <span class="comment">//二重循环遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遇到一个 1 作为正方形的左上角</span></span><br><span class="line">                    maxSide = max(maxSide, <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 计算可能的最大正方形边长</span></span><br><span class="line">                    <span class="keyword">int</span> currentMaxSide = min(rows - i, columns - j);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; currentMaxSide; k++) &#123;</span><br><span class="line">                        <span class="comment">// 判断新增的一行一列是否均为 1</span></span><br><span class="line">                        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (matrix[i + k][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matrix[i + k][j + m] == <span class="string">'0'</span> || matrix[i + m][j + k] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                            maxSide = max(maxSide, k + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基本没啥差别，和我写的</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><blockquote>
<ul>
<li>时间复杂度：$O(m<em>n</em>min(m,n)^2)$；遍历整个矩阵的时间复杂度为$O(m*n)$，对于正方形，遍历的事件复杂度为$O(min(m,n)^2)$</li>
<li>空间复杂度：$O(1)$，整个过程中使用的空间复杂度是常数</li>
</ul>
</blockquote>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>$dp(i,j)$表示以$(i,j)$为右下角，且只包含$1$的正方形的边长最大值。</p>
<p>如果<code>matrix[i][j]==0</code>，那么显然不可能在一个只含有$1$的正方形中，因此$dp(i,j)=0$</p>
<p>如果<code>matrix[i][j]==1</code>，那么显然<code>dp[i][j]=min(dp(i-1,j),dp(i-1,j-1),dp(i,j-1))+1</code>。</p>
<p>得出状态转移方程</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span> || matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;  <span class="comment">//判断矩形的形状</span></span><br><span class="line">        <span class="keyword">int</span> maxSide = <span class="number">0</span>;    <span class="comment">//正方形的最大边长</span></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.size(), columns = matrix[<span class="number">0</span>].size();   <span class="comment">//判断一下行，列</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(columns))</span></span>;     <span class="comment">//创建一个dp矩形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;     <span class="comment">//二重循环遍历，动态规划</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = min(min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide = max(maxSide, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxSquare = maxSide * maxSide;</span><br><span class="line">        <span class="keyword">return</span> maxSquare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：$O(mn)$，整个过程中只进行两层遍历</li>
<li>空间复杂度：$O(mn)$，创建了一个和原始矩阵大小相同的矩阵$dp$</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0007%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0007%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/" class="post-title-link" itemprop="url">0007另一个数的子树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-07 23:30:00" itemprop="dateCreated datePublished" datetime="2020-05-07T23:30:00+08:00">2020-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0007%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/07/每天一道算法题/0007 另一个树的子树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>另一个树的子树</font>

<blockquote>
<p>编号：0007</p>
<p>题目来源：<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空二叉树$s$和$t$，检验$s$中是否包含和$t$具有相同结构和节点值的子树。$s$的一个子树包括$s$的一个节点和这个节点的所有子孙。$s$也可以看作它自身的一棵子树。</p>
<p>树的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul>
<li><p><img src="0007-01.jpg" alt="示例1"></p>
</li>
<li><p><img src="0007-02.jpg" alt="示例2"></p>
</li>
</ul>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方解答传送门</a></p>
<h2 id="递归检查"><a href="#递归检查" class="headerlink" title="递归检查"></a>递归检查</h2><blockquote>
<p>自己写的思路如下</p>
</blockquote>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>因为要求判断$s$中是否含有$t$这样的子树，那也就是说，如果含有就会有$s$的一个子树和$t$完全一样。所以可以递归的进行判断：如果$s$和$t$相同，那么显然返回<code>true</code>，如果不同，再分别那$s$的左子树和右子树和$t$进行比较，如果其中有相同的也返回$true$，一直递归到最后$s$变成$NULL$，递归终止。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;  <span class="comment">//判断是否为子树的递归调用</span></span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">NULL</span>)              <span class="comment">//空子树，递归终止</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (ifTheSame(s, t))        <span class="comment">//如果检查s和t一样，返回true</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> (isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t));<span class="comment">//检查左右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">ifTheSame</span><span class="params">(TreeNode* s, TreeNode* t)</span>  <span class="comment">//判断两个树是否完全相同，也是递归判断</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>)          </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((s == <span class="literal">NULL</span> &amp;&amp; t != <span class="literal">NULL</span>) || (s != <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (s-&gt;val == t-&gt;val)</span><br><span class="line">			<span class="keyword">return</span> (ifTheSame(s-&gt;left, t-&gt;left) &amp;&amp; ifTheSame(s-&gt;right, t-&gt;right));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>官方题解</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((o &amp;&amp; !t) || (!o &amp;&amp; t) || (o-&gt;val != t-&gt;val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(o-&gt;left, t-&gt;left) &amp;&amp; check(o-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *o, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!o) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(o, t) || dfs(o-&gt;left, t) || dfs(o-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode *s, TreeNode *t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：整个过程中总的时间是遍历s树的时间和每次比较的时间相乘，即$O(s\times t)$</p>
<p>空间复杂度：整个过程中用了两个递归函数，isSubtree更多依赖于s树的深度，ifTheSame更多依赖于t树的深度，最后的空间复杂度就是两者的较大值</p>
</blockquote>
<h2 id="DFS-序列上进行串匹配"><a href="#DFS-序列上进行串匹配" class="headerlink" title="$DFS$序列上进行串匹配"></a>$DFS$序列上进行串匹配</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>先序遍历(DFS)生成的序列中，子树是连续的，因此可以通过判断t生成的DFS序列是否是s的DFS的序列的子串。</p>
<p>但是这样做是不完全正确的，因为还存在即使是子串，但是左右位置发生变化，例如1是根，2是左孩子和1是根，2是右孩子的DFS序列相同，但是不是一个树，因此需要添加两个空值<code>lNull</code>和<code>rNull</code>，生成DFS序列之后，就可以进行子序列的匹配了。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sOrder, tOrder;  <span class="comment">//用来存放两个DFS序列</span></span><br><span class="line">    <span class="keyword">int</span> maxElement, lNull, rNull;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMaxElement</span><span class="params">(TreeNode *o)</span> </span>&#123;  <span class="comment">//得到树o的最大节点值，放入全局变量maxElement中，递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (!o) <span class="keyword">return</span>;</span><br><span class="line">        maxElement = max(maxElement, o-&gt;val);</span><br><span class="line">        getMaxElement(o-&gt;left);</span><br><span class="line">        getMaxElement(o-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDfsOrder</span><span class="params">(TreeNode *o, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;tar)</span> </span>&#123; <span class="comment">//得到树o的DFS序列，放入tar中，递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (!o) <span class="keyword">return</span>;</span><br><span class="line">        tar.push_back(o-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;left) getDfsOrder(o-&gt;left, tar);</span><br><span class="line">        <span class="keyword">else</span> tar.push_back(lNull);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;right) getDfsOrder(o-&gt;right, tar);</span><br><span class="line">        <span class="keyword">else</span> tar.push_back(rNull);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = sOrder.size(), tLen = tOrder.size();</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fail(tOrder.size(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; tLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; tOrder[i] != tOrder[j + <span class="number">1</span>]) j = fail[j];</span><br><span class="line">            <span class="keyword">if</span> (tOrder[i] == tOrder[j + <span class="number">1</span>]) ++j;</span><br><span class="line">            fail[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; sLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; sOrder[i] != tOrder[j + <span class="number">1</span>]) j = fail[j];</span><br><span class="line">            <span class="keyword">if</span> (sOrder[i] == tOrder[j + <span class="number">1</span>]) ++j;</span><br><span class="line">            <span class="keyword">if</span> (j == tLen - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        maxElement = INT_MIN;</span><br><span class="line">        getMaxElement(s);</span><br><span class="line">        getMaxElement(t);</span><br><span class="line">        lNull = maxElement + <span class="number">1</span>;</span><br><span class="line">        rNull = maxElement + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        getDfsOrder(s, sOrder);</span><br><span class="line">        getDfsOrder(t, tOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kmp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用到了$KMP$算法，有丢丢不好理解，丢一个我觉得讲的很好的连接：<a href="https://blog.csdn.net/dark_cy/article/details/88698736" target="_blank" rel="noopener">CSDN</a>，理解了他画红的，基本上就理解了KMP算法。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<ul>
<li>时间复杂度：由于使用了KMP算法，因此最终事件复杂度$O(s+t)$，递归遍历两棵树的时间之和</li>
<li>空间复杂度：保存了两个DFS序列，辅助空间代价$O(s+t)$，两个栈空间，是$O(max\{d_s,d_t\})$，两棵树的深度的较大值，因此求和还为$O(s+t)$</li>
</ul>
</blockquote>
<p><strong>今日最大收获，KMP算法</strong></p>
<p>官方的hash算法我不太懂，就不贴了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0006%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leading Werido">
      <meta itemprop="description" content="笔记记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Something">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0006%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="post-title-link" itemprop="url">0006验证二叉搜索树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-05 13:19:00" itemprop="dateCreated datePublished" datetime="2020-05-05T13:19:00+08:00">2020-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 00:17:10" itemprop="dateModified" datetime="2020-06-09T00:17:10+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">每天一道算法题</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98/0006%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/05/每天一道算法题/0006 验证二叉搜索树/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font size=8>验证二叉搜索树</font>

<blockquote>
<p>编号：0006</p>
<p>试题来源：<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">leetcode</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>二叉搜索树的特征如下:</p>
<ul>
<li>节点的左子树只包含小于当前节点的数</li>
<li>节点的右子树只包含大于当前节点的数</li>
<li>所有的左子树和右子树自身必须也是二叉搜索树</li>
</ul>
<p>该题目中二叉树的结构定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode *left;</span><br><span class="line">      TreeNode *right;</span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul>
<li><blockquote>
<p>  <img src="0006-01.jpg" alt="0006-01"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="0006-02.jpg" alt="0006-02"></p>
</blockquote>
</li>
</ul>
<h1 id="解答算法"><a href="#解答算法" class="headerlink" title="解答算法"></a>解答算法</h1><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方解答</a></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>因为要满足右子树的所有值大于节点，左子树的所有值小于节点，那么因此每一个节点上的数都应该有其理论最大值和最小值<code>max</code>和<code>min</code>，节点上的数要在<code>(min,max)</code>之间，然后当更新对该节点的左节点进行判断，那么<code>max</code>要改变为<code>root-&gt;val</code>，同样的，更新对右节点进行判断，<code>min</code>改变为<code>root-&gt;val</code>。</p>
<p>在最开始的根节点，<code>min</code>和<code>max</code>的初值我设定的是<code>long long</code>格式的<code>LLONG_MAX</code>和<code>LLONG_MIN</code>，因为树上的节点可能存在有确实值为<code>INT_MAX</code>和<code>INT_MIN</code>的情况，这样可能无法判断。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)     <span class="comment">//若根节点就为空，直接认为是二叉搜索树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;left,root-&gt;val,LLONG_MIN))  <span class="comment">//&amp;&amp;运算符先判断前部分，若root-&gt;left为空，不进行后面的判断，否则进入递归循环，对其左子树进行判断，最大值为root-&gt;val，最小值为LLONG_MIN</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;right,LLONG_MAX,root-&gt;val))<span class="comment">//同对左子树的判断，区别只是最小值改变为root-&gt;val</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//如果两重检验均成功，那么返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> max, <span class="keyword">long</span> <span class="keyword">long</span> min)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(root-&gt;val &gt; min &amp;&amp; root-&gt;val &lt; max))   <span class="comment">//判断节点值是否在(min,max)之间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;left,root-&gt;val,min))<span class="comment">//判断左子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; !isValid(root-&gt;right,max,root-&gt;val))<span class="comment">//判断右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">long</span> <span class="keyword">long</span> lower, <span class="keyword">long</span> <span class="keyword">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比我的简洁在原函数中没有对根节点进行额外的判断，而是也像正常的节点一样扔进递归中。</p>
<p>同时递归中的根节点判断是否为空也是扔进递归中，而不是进入递归之前。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度：递归调用过程中，所有的节点都要被访问一次，进行条件判断，因此时间复杂度为$O(n)$</p>
<p>空间复杂度：为栈空间所占内存，也即递归的深度，当二叉树仅有一条链的时候，递归深度为n，因此时间复杂度为$O(n)$</p>
</blockquote>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>二叉搜索树中序遍历得到的值构成的序列一定是升序的。因此可以通过检验升序遍历过程中，当前节点是否大于前一节点的值即可。</p>
<p><strong>中序遍历</strong>就是先遍历左子树，再遍历根节点，最后遍历右子树</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;    <span class="comment">//利用栈实现中序遍历</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> inorder = (<span class="keyword">long</span> <span class="keyword">long</span>)INT_MIN - <span class="number">1</span>;  <span class="comment">//初始定义前一个节点的值为int值得最小减1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() || root != <span class="literal">nullptr</span>) &#123; <span class="comment">//中序遍历</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;   <span class="comment">//遍历完其左子树</span></span><br><span class="line">                <span class="built_in">stack</span>.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = <span class="built_in">stack</span>.top();        <span class="comment">//弹出左节点</span></span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (root -&gt; val &lt;= inorder) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p>时间复杂度分析：要访问二叉搜索树的每一个节点，因此时间复杂度为$O(n)$</p>
<p>空间复杂度分析：栈存储的空间，在极端情况下，二叉搜索树仅有一条链，那么就会导致栈存储n，因此空间复杂度$O(n)$</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leading Werido</p>
  <div class="site-description" itemprop="description">笔记记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leading Werido</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://leadingWerido.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
